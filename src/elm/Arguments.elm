module Arguments exposing
  ( Arguments
  , parse
  , parseHelp, showHelp
  )

{- Imports ------------------------------------------------------------------ -}
import Dict exposing (Dict)
import Parser exposing (Parser, (|=), (|.))
import Regex


{- Types -------------------------------------------------------------------- -}
{-| These are the command line arguments that get passed into our Elm program.
Only "name" and "prefix" are strictly necessary, the rest can be defaulted from
those values.

  • name    <- The name of the package to prefix, this is the full package name
               including the author.
  • tag     <- The version tag; either a semver number or "latest".
  • author  <- GitHub username of the *new* author of the prefixed package.
  • prefix  <- Prefix to namespace the package's functions. Has to be a valid
            <- Elm module path like Some.Module.Path
  • dir     <- Path to place the generated files.

You can read the docs generated by the `showHelp` function to see how the defaults
are generated.
-}
type alias Arguments =
  { name : String
  , tag : String
  , author : String
  , prefix : String
  , dir : String
  }

{-| The variants of this type correspond to the fields of the Arguments record
above. These exist so we can parse the "--help" command now what command the
user wants explained.

This type is used entirely internally, we don't even need to expose it.
-}
type HelpArgument
  = Name
  | Tag
  | Author
  | Prefix
  | Dir

{- Args Parsers ------------------------------------------------------------- -}
{-| -}
parse : String -> Result (List Parser.DeadEnd) Arguments
parse input =
  Parser.run parseArguments input

{-| -}
parseArguments : Parser Arguments
parseArguments =
  let
    parseArg parser =
      Parser.succeed Parser.Loop
        |. Parser.spaces
        |= parser
        |. Parser.spaces

    argumentsFromDict args =
      Maybe.map2 Tuple.pair (Dict.get "name" args) (Dict.get "prefix" args)
        |> Maybe.map (\(name, prefix) ->
            { name = name
            , tag =
                Dict.get "tag" args
                  |> Maybe.withDefault "latest"
            , author =
                Dict.get "author" args
                  |> Maybe.withDefault (name |> String.split "/" |> List.head |> Maybe.withDefault "")
            , prefix = prefix
            , dir =
                Dict.get "dir" args
                  |> Maybe.withDefault "./" 
            }
          )
        |> Maybe.map Parser.succeed
        |> Maybe.withDefault (Parser.problem "")

  in
  Parser.andThen argumentsFromDict <| Parser.loop Dict.empty (\args ->
    Parser.oneOf
      [ parseArg (parsePackageName args)
      , parseArg (parseTag args)
      , parseArg (parseAuthor args)
      , parseArg (parsePrefix args)
      , parseArg (parseOutDir args)
      , Parser.succeed (\_ -> Parser.Done args)
          |= Parser.end
      ]
  )

{-| -}
parsePackageName : Dict String String -> Parser (Dict String String)
parsePackageName args =
  let
    regex =
      Regex.fromString "\\S+\\/\\S+"
        |> Maybe.withDefault Regex.never
  in
  Parser.succeed identity
    |. Parser.oneOf
      [ Parser.symbol "--package-name"
      , Parser.symbol "-n"
      ]
    |. Parser.spaces
    |= Parser.getChompedString (Parser.chompUntilEndOr " ")
    |> Parser.andThen (\packageName ->
      if Regex.contains regex packageName then
        Parser.succeed (Dict.insert "name" packageName args)

      else
        Parser.problem "Package name does not match author/package regex."
    )

{-| -}
parseTag : Dict String String -> Parser (Dict String String)
parseTag args =
  let
    regex =
      Regex.fromString "\\d+\\.\\d+\\.\\d+"
        |> Maybe.withDefault Regex.never
  in
  Parser.succeed identity
    |. Parser.oneOf
      [ Parser.symbol "--tag"
      , Parser.symbol "-t"
      ]
    |. Parser.spaces
    |= Parser.getChompedString (Parser.chompUntilEndOr " ")
    |> Parser.andThen (\tag ->
      if tag == "latest" then
        Parser.succeed (Dict.insert "tag" tag args)

      else if Regex.contains regex tag then
        Parser.succeed (Dict.insert "tag" tag args)

      else
        Parser.problem "Package name does not match package tag regex."
    )

{-| -}
parseAuthor : Dict String String -> Parser (Dict String String)
parseAuthor args =
  let
    regex =
      Regex.fromString "[a-zA-Z]\\S+"
        |> Maybe.withDefault Regex.never
  in
  Parser.succeed identity
    |. Parser.oneOf
      [ Parser.symbol "--author"
      , Parser.symbol "-a"
      ]
    |. Parser.spaces
    |= Parser.getChompedString (Parser.chompUntilEndOr " ")
    |> Parser.andThen (\author ->
      if Regex.contains regex author then
        Parser.succeed (Dict.insert "author" author args)

      else
        Parser.problem "Package name does not match package tag regex."
    )

{-| -}
parsePrefix : Dict String String -> Parser (Dict String String)
parsePrefix args =
  let
    regex =
      Regex.fromString "[A-Z]\\w+(?:\\.[A-Z]\\w+)*"
        |> Maybe.withDefault Regex.never
  in
  Parser.succeed identity
    |. Parser.oneOf
      [ Parser.symbol "--prefix"
      , Parser.symbol "-p"
      ]
    |. Parser.spaces
    |= Parser.getChompedString (Parser.chompUntilEndOr " ")
    |> Parser.andThen (\prefix ->
      if Regex.contains regex prefix then
        Parser.succeed (Dict.insert "prefix" prefix args)

      else
        Parser.problem "Package name does not match prefix regex."
    )

{-| -}
parseOutDir : Dict String String -> Parser (Dict String String)
parseOutDir args =
  Parser.succeed identity
    |. Parser.oneOf
      [ Parser.symbol "--out-dir"
      , Parser.symbol "-d"
      ]
    |. Parser.spaces
    |= Parser.getChompedString (Parser.chompUntilEndOr " ")
    |> Parser.map (\dir -> Dict.insert "dir" dir args)


{- Help Parsers ------------------------------------------------------------- -}
{-| -}
showHelp : Maybe HelpArgument -> String
showHelp argument =
  case argument of
    Just Name ->
      String.join "\n"
        [ "--package-name, -n"
        , ""
        , "The name of the package to prefix. This should be formatted as author/package"
        , "as it is when doing elm install."
        , ""
        , "Usage:"
        , ""
        , "    --package-name elm/html"
        , "    -n elm/html"
        , ""
        , "This argument is *required*."
        ]

    Just Tag ->
      String.join "\n"
        [ "--tag, -t"
        , ""
        , "The version tag of the package you want to prefix. You can navigate to"
        , "https://package.elm-lang.org/packages/author/package/ to see the"
        , "published tags. Instead of a tag number you may also use 'latest' to"
        , "grab the most recent published version."
        , ""
        , "Usage:"
        , ""
        , "    --tag 1.2.0"
        , "    -t latest"
        , ""
        , "This argument is *optional* and defaults to 'latest'."
        ]

    Just Author ->
      String.join "\n"
        [ "--author, -a"
        , ""
        , "The name of the author to use when generating the new package. This"
        , "follows the same rules as when publishing a normal Elm package and"
        , "should be the GitHub username of whoever is going to publish the"
        , "package."
        , ""
        , "Usage:"
        , ""
        , "  --author pd-andy"
        , "  -a pd-andy"
        , ""
        , "This argument is *optional* and defaults to the author of the target"
        , "package."
        ]

    Just Prefix ->
      String.join "\n"
        [ "--prefix, -p"
        , ""
        , "The prefix to use when generating the new package. This needs to be"
        , "a valid Elm module path but multiple prefixes are allowed."
        , ""
        , "Usage:"
        , ""
        , "    --prefix Core"
        , "    --p A.Very.Nested.Prefix"
        , ""
        , "This argument is *required*."
        ]

    Just Dir ->
      String.join "\n"
        [ "--out-dir, -d"
        , ""
        , "The directory where the generated package will be placed. This will"
        , "include all the generated source code and the modified elm.json."
        , ""
        , "Usage:"
        , ""
        , "    --out-dir ./elm-core/"
        , "    -d /absolute/path"
        , ""
        , "This argument is *optional* and defaults to the current working"
        , "directory."
        ]

    Nothing ->
      String.join "\n"
        [ ""
        , "You might ocassionally run into an issue where a package you're using"
        , "exposes a module that has the same name as a module you have written."
        , "For user applications this isn't world-breaking, we can always move our"
        , "own modules somewhere else or rename them. For packages that rely on"
        , "other packages though, this isn't as simple."
        , ""
        , "Renaming a module would cause a major version change for something"
        , "that really shouldn't. Until the compiler comes up with a permanent"
        , "solution, this little program serves as a stop-gap to generate a"
        , "prefixed version of a package that can be published and used as the"
        , "dependency instead."
        , ""
        , "Example:"
        , ""
        , "  elm-package-prefixer -n ianmackenzie/elm-units -t latest -a pd-andy -p Units -d ./elm-units"
        ,""
        , "Arguments:"
        , ""
        , "  --package-name, -n   [required] The name of the package to prefix."
        , "  --tag, -t            [optional] The version tag to pull from."
        , "  --author, -a         [optional] The author of the generated package."
        , "  --prefix, -p         [required] The prefix to use when generating."
        , "  --out-dir, -d        [optional] The directory to save the generated package."
        , ""
        , "  --help                          Show this message!"
        , "  --help [argument]               Show more detailed info about a particular"
        , "                                  argument."
        , ""
        ]

{-| -}
parseHelp : String -> Maybe HelpArgument
parseHelp input =
  Parser.run parseHelpArgument input
    |> Result.toMaybe

{-| -}
parseHelpArgument : Parser HelpArgument
parseHelpArgument =
  let
    parseArg option symbol =
      Parser.succeed option
        |. Parser.spaces
        |. Parser.symbol symbol
  in
  Parser.succeed identity 
    |. Parser.symbol "--help"
    |. Parser.spaces
    |= Parser.oneOf
      [ parseArg Name "--package-name"
      , parseArg Name "-n"
      , parseArg Tag "--tag"
      , parseArg Tag "-t"
      , parseArg Author "--author"
      , parseArg Author "-a"
      , parseArg Prefix "--prefix"
      , parseArg Prefix "-p"
      , parseArg Dir "--out-dir"
      , parseArg Dir "-d"
      ]
