module Arguments exposing
    ( Arguments
    , parse
    , parseHelp
    , showHelp
    )

{- Imports ------------------------------------------------------------------ -}

import Dict exposing (Dict)
import Parser exposing ((|.), (|=), Parser)
import Regex



{- Types -------------------------------------------------------------------- -}


{-| These are the command line arguments that get passed into our Elm program.
Only "name" and "prefix" are strictly necessary, the rest can be defaulted from
those values.

• name <- The name of the package to prefix, this is the full package name
including the author.
• tag <- The version tag; either a semver number or "latest".
• author <- GitHub username of the _new_ author of the prefixed package.
• prefix <- Prefix to namespace the package's functions. Has to be a valid
<- Elm module path like Some.Module.Path
• dir <- Path to place the generated files.

You can read the docs generated by the `showHelp` function to see how the defaults
are generated.

-}
type alias Arguments =
    { name : String
    , tag : String
    , author : String
    , prefix : String
    , dir : String
    }


{-| The variants of this type correspond to the fields of the Arguments record
above. These exist so we can parse the "--help" command now what command the
user wants explained.

This type is used entirely internally, we don't even need to expose it.

-}
type HelpArgument
    = Name
    | Tag
    | Author
    | Prefix
    | Dir



{- Args Parsers ------------------------------------------------------------- -}


{-| -}
parse : String -> Result (List Parser.DeadEnd) Arguments
parse input =
    Parser.run parseArguments input


{-| -}
parseArguments : Parser Arguments
parseArguments =
    let
        parseArg parser =
            Parser.succeed Parser.Loop
                |. Parser.spaces
                |= parser
                |. Parser.spaces

        argumentsFromDict args =
            Maybe.map2 Tuple.pair (Dict.get "name" args) (Dict.get "prefix" args)
                |> Maybe.map
                    (\( name, prefix ) ->
                        { name = name
                        , tag =
                            Dict.get "tag" args
                                |> Maybe.withDefault "latest"
                        , author =
                            Dict.get "author" args
                                |> Maybe.withDefault (name |> String.split "/" |> List.head |> Maybe.withDefault "")
                        , prefix = prefix
                        , dir =
                            Dict.get "dir" args
                                |> Maybe.withDefault "./"
                        }
                    )
                |> Maybe.map Parser.succeed
                |> Maybe.withDefault (Parser.problem "")
    in
    Parser.andThen argumentsFromDict <|
        Parser.loop Dict.empty
            (\args ->
                Parser.oneOf
                    [ parseArg (parsePackageName args)
                    , parseArg (parseTag args)
                    , parseArg (parseAuthor args)
                    , parseArg (parsePrefix args)
                    , parseArg (parseOutDir args)
                    , Parser.succeed (\_ -> Parser.Done args)
                        |= Parser.end
                    ]
            )


{-| -}
parsePackageName : Dict String String -> Parser (Dict String String)
parsePackageName args =
    let
        regex =
            Regex.fromString "\\S+\\/\\S+"
                |> Maybe.withDefault Regex.never
    in
    Parser.succeed identity
        |. Parser.oneOf
            [ Parser.symbol "--package-name"
            , Parser.symbol "-n"
            ]
        |. Parser.spaces
        |= Parser.getChompedString (Parser.chompUntilEndOr " ")
        |> Parser.andThen
            (\packageName ->
                if Regex.contains regex packageName then
                    Parser.succeed (Dict.insert "name" packageName args)

                else
                    Parser.problem "Package name does not match author/package regex."
            )


{-| -}
parseTag : Dict String String -> Parser (Dict String String)
parseTag args =
    let
        regex =
            Regex.fromString "\\d+\\.\\d+\\.\\d+"
                |> Maybe.withDefault Regex.never
    in
    Parser.succeed identity
        |. Parser.oneOf
            [ Parser.symbol "--tag"
            , Parser.symbol "-t"
            ]
        |. Parser.spaces
        |= Parser.getChompedString (Parser.chompUntilEndOr " ")
        |> Parser.andThen
            (\tag ->
                if tag == "latest" then
                    Parser.succeed (Dict.insert "tag" tag args)

                else if Regex.contains regex tag then
                    Parser.succeed (Dict.insert "tag" tag args)

                else
                    Parser.problem "Package name does not match package tag regex."
            )


{-| -}
parseAuthor : Dict String String -> Parser (Dict String String)
parseAuthor args =
    let
        regex =
            Regex.fromString "[a-zA-Z]\\S+"
                |> Maybe.withDefault Regex.never
    in
    Parser.succeed identity
        |. Parser.oneOf
            [ Parser.symbol "--author"
            , Parser.symbol "-a"
            ]
        |. Parser.spaces
        |= Parser.getChompedString (Parser.chompUntilEndOr " ")
        |> Parser.andThen
            (\author ->
                if Regex.contains regex author then
                    Parser.succeed (Dict.insert "author" author args)

                else
                    Parser.problem "Package name does not match package tag regex."
            )


{-| -}
parsePrefix : Dict String String -> Parser (Dict String String)
parsePrefix args =
    let
        regex =
            Regex.fromString "[A-Z]\\w+(?:\\.[A-Z]\\w+)*"
                |> Maybe.withDefault Regex.never
    in
    Parser.succeed identity
        |. Parser.oneOf
            [ Parser.symbol "--prefix"
            , Parser.symbol "-p"
            ]
        |. Parser.spaces
        |= Parser.getChompedString (Parser.chompUntilEndOr " ")
        |> Parser.andThen
            (\prefix ->
                if Regex.contains regex prefix then
                    Parser.succeed (Dict.insert "prefix" prefix args)

                else
                    Parser.problem "Package name does not match prefix regex."
            )


{-| -}
parseOutDir : Dict String String -> Parser (Dict String String)
parseOutDir args =
    Parser.succeed identity
        |. Parser.oneOf
            [ Parser.symbol "--out-dir"
            , Parser.symbol "-d"
            ]
        |. Parser.spaces
        |= Parser.getChompedString (Parser.chompUntilEndOr " ")
        |> Parser.map (\dir -> Dict.insert "dir" dir args)



{- Help Parsers ------------------------------------------------------------- -}


{-| -}
showHelp : Maybe HelpArgument -> String
showHelp argument =
    case argument of
        Just Name ->
            String.join "\n"
                [ "--package-name, -n"
                , ""
                , "The name of the package to prefix. This should be formatted as author/package"
                , "as it is when doing elm install."
                , ""
                , "Usage:"
                , ""
                , "    --package-name elm/html"
                , "    -n elm/html"
                , ""
                , "This argument is *required*."
                ]

        Just Tag ->
            String.join "\n"
                [ "--tag, -t"
                , ""
                , "The version tag of the package you want to prefix. You can navigate to"
                , "https://package.elm-lang.org/packages/author/package/ to see the"
                , "published tags. Instead of a tag number you may also use 'latest' to"
                , "grab the most recent published version."
                , ""
                , "Usage:"
                , ""
                , "    --tag 1.2.0"
                , "    -t latest"
                , ""
                , "This argument is *optional* and defaults to 'latest'."
                ]

        Just Author ->
            String.join "\n"
                [ "--author, -a"
                , ""
                , "The name of the author to use when generating the new package. This"
                , "follows the same rules as when publishing a normal Elm package and"
                , "should be the GitHub username of whoever is going to publish the"
                , "package."
                , ""
                , "Usage:"
                , ""
                , "    --author pd-andy"
                , "    -a pd-andy"
                , ""
                , "This argument is *optional* and defaults to the author of the target"
                , "package."
                ]

        Just Prefix ->
            String.join "\n"
                [ "--prefix, -p"
                , ""
                , "The prefix to use when generating the new package. This needs to be"
                , "a valid Elm module path but multiple prefixes are allowed."
                , ""
                , "Usage:"
                , ""
                , "    --prefix Core"
                , "    --p A.Very.Nested.Prefix"
                , ""
                , "This argument is *required*."
                ]

        Just Dir ->
            String.join "\n"
                [ "--out-dir, -d"
                , ""
                , "The directory where the generated package will be placed. This will"
                , "include all the generated source code and the modified elm.json."
                , ""
                , "Usage:"
                , ""
                , "    --out-dir ./elm-core/"
                , "    -d /absolute/path"
                , ""
                , "This argument is *optional* and defaults to the current working"
                , "directory."
                ]

        Nothing ->
            String.join "\n"
                [ ""
                , "You might ocassionally run into an issue where a package you're using"
                , "exposes a module that has the same name as a module you have written."
                , "For user applications this isn't world-breaking, we can always move our"
                , "own modules somewhere else or rename them. For packages that rely on"
                , "other packages though, this isn't as simple."
                , ""
                , "Renaming a module would cause a major version change for something"
                , "that really shouldn't. Until the compiler comes up with a permanent"
                , "solution, this little program serves as a stop-gap to generate a"
                , "prefixed version of a package that can be published and used as the"
                , "dependency instead."
                , ""
                , "Example:"
                , ""
                , "  elm-package-prefixer -n ianmackenzie/elm-units -t latest -a pd-andy -p Units -d ./elm-units"
                , ""
                , "Arguments:"
                , ""
                , "  --package-name, -n   [required] The name of the package to prefix."
                , "  --tag, -t            [optional] The version tag to pull from."
                , "  --author, -a         [optional] The author of the generated package."
                , "  --prefix, -p         [required] The prefix to use when generating."
                , "  --out-dir, -d        [optional] The directory to save the generated package."
                , ""
                , "  --help                          Show this message!"
                , "  --help [argument]               Show more detailed info about a particular"
                , "                                  argument."
                , ""
                ]


{-| -}
parseHelp : String -> Maybe HelpArgument
parseHelp input =
    Parser.run parseHelpArgument input
        |> Result.toMaybe


{-| -}
parseHelpArgument : Parser HelpArgument
parseHelpArgument =
    let
        parseArg option symbol =
            Parser.succeed option
                |. Parser.spaces
                |. Parser.symbol symbol
    in
    Parser.succeed identity
        |. Parser.symbol "--help"
        |. Parser.spaces
        |= Parser.oneOf
            [ parseArg Name "--package-name"
            , parseArg Name "-n"
            , parseArg Tag "--tag"
            , parseArg Tag "-t"
            , parseArg Author "--author"
            , parseArg Author "-a"
            , parseArg Prefix "--prefix"
            , parseArg Prefix "-p"
            , parseArg Dir "--out-dir"
            , parseArg Dir "-d"
            ]
